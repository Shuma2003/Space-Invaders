План реализации игры "Space Invaders" (упрощенная версия)
Цель: Создать работающую 2D игру в браузере, где игрок управляет пушкой, стреляет в надвигающихся пришельцев и набирает очки.

Файловая структура проекта:

text
space-invaders/
│
├── index.html
├── style.css
└── script.js
Последовательность шагов (промптов):
Шаг 1: Настройка базовой HTML-структуры и игрового поля

Задача: Создать основной файл HTML и настроить Canvas для отрисовки игры.

Детальные инструкции для агента:

Создай файл index.html.

Внутри файла создай базовую структуру HTML5 документа.

Добавь тег <canvas> с id="gameCanvas" и размерами 800x600 пикселей.

Подключи файлы style.css и script.js в правильном порядке (CSS в <head>, JS перед закрывающим тегом </body>).

Создай файл style.css и задай черный фон для всего тела документа (body). Для элемента canvas добавь стиль display: block; и margin: 0 auto;, чтобы центрировать его на странице.

Создай файл script.js. Внутри него получи ссылку на элемент <canvas> и его 2D-контекст. Сохрани их в переменные (например, canvas и ctx).

В script.js залей весь холст (canvas) черным цветом, используя методы контекста (ctx.fillStyle, ctx.fillRect), чтобы убедиться, что все работает.

Шаг 2: Создание игрока (пушки) и базового управления

Задача: Нарисовать игрока в нижней части экрана и сделать так, чтобы он двигался влево и вправо с помощью клавиш.

Детальные инструкции для агента:

В script.js создай объект player со свойствами:

x: координата X (начальное значение: середина canvas по ширине)

y: координата Y (начальное значение: near the bottom, e.g., canvas.height - 20)

width: ширина (e.g., 40)

height: высота (e.g., 20)

speed: скорость перемещения (e.g., 5)

Создай функцию drawPlayer(). Внутри нее используй ctx.fillStyle и ctx.fillRect, чтобы нарисовать прямоугольник, представляющий игрока, используя свойства из объекта player.

Вызови drawPlayer() в скрипте после заливки холста черным цветом. Убедись, что пушка появилась.

Реализуй обработку ввода с клавиатуры.

Создай объект keys = {} для отслеживания нажатых клавиш.

Добавь обработчики событий addEventListener для keydown и keyup. При нажатии клавиши устанавливай keys[keyCode] = true, при отпускании — false.

Отслеживай клавиши "Стрелка влево" (код 37) и "Стрелка вправо" (код 39).

Создай функцию updatePlayer(). Внутри нее, в зависимости от состояния keys[37] и keys[39], изменяй свойство player.x, не позволяя игроку выйти за границы холста.

Шаг 3: Введение игрового цикла

Задача: Создать непрерывный игровой цикл, который будет обновлять состояние игры и перерисовывать кадры.

Детальные инструкции для агента:

Создай функцию gameLoop().

Внутри gameLoop:

Очищай весь холст, заливая его черным цветом.

Вызывай updatePlayer() для обновления позиции игрока на основе нажатых клавиш.

Вызывай drawPlayer() для отрисовки игрока в новой позиции.

Используй requestAnimationFrame(gameLoop) в конце функции gameLoop, чтобы запустить следующий кадр.

Вызови gameLoop() один раз в начале, чтобы запустить цикл.

Протестируй управление. Движение игрока теперь должно быть плавным.

Шаг 4: Реализация стрельбы игрока

Задача: Позволить игроку выпускать снаряды по нажатию клавиши "Пробел".

Детальные инструкции для агента:

Создай массив bullets = [] для хранения всех активных снарядов.

Каждый снаряд — это объект с свойствами: x, y, width, height, speed (отрицательное число, т.к. летит вверх).

В обработчике событий клавиатуры добавь отслеживание клавиши "Пробел" (код 32). При нажатии (keydown) создавай новый объект снаряда. Его начальные координаты x и y должны быть рассчитаны так, чтобы он появлялся из "дула" пушки (например, player.x + player.width/2, player.y).

Создай функцию updateBullets().

В цикле проходи по всем снарядам в массиве bullets.

Обновляй их координату y, прибавляя speed.

Если снаряд вылетел за верхнюю границу холста (y < 0), удаляй его из массива (используй splice).

Создай функцию drawBullets(), которая в цикле отрисовывает каждый снаряд (например, белым прямоугольником).

В основном игровом цикле gameLoop добавь вызовы updateBullets() и drawBullets() после обновления и отрисовки игрока.

Шаг 5: Создание врагов (пришельцев)

Задача: Создать сетку врагов в верхней части экрана.

Детальные инструкции для агента:

Создай массив enemies = [].

Создай функцию createEnemies(). Внутри нее с помощью вложенных циклов (например, 5 рядов по 10 врагов) заполни массив enemies объектами.

Каждый враг — это объект со свойствами: x, y, width, height, alive: true.

Рассчитай начальные позиции так, чтобы враги образовывали ровную сетку с отступами.

Создай функцию drawEnemies(), которая в цикле проходит по массиву enemies и для каждого врага, у которого alive равно true, рисует прямоугольник (например, зеленого цвета) на его позиции.

Вызови createEnemies() один раз при старте игры и добавь вызов drawEnemies() в игровой цикл. Убедись, что сетка врагов отображается.

Шаг 6: Реализация столкновений "снаряд-враг"

Задача: Снаряды игрока должны уничтожать врагов при попадании.

Детальные инструкции для агента:

Создай функцию checkCollisions().

Внутри функции организуй два вложенных цикла: по всем снарядам и по всем врагам.

Для каждой пары "снаряд-враг" проверь, пересекаются ли их прямоугольники (AABB-коллизия). Условие: снаряд находится в пределах врага по X и Y.

bullet.x < enemy.x + enemy.width

bullet.x + bullet.width > enemy.x

bullet.y < enemy.y + enemy.height

bullet.y + bullet.height > enemy.y

Если коллизия обнаружена и враг еще жив:

Помечай врага как alive: false.

Удаляй снаряд из массива bullets (и прерви внутренний цикл для этого снаряда с помощью break, чтобы один снаряд не мог попасть в нескольких врагов).

Добавь вызов checkCollisions() в игровой цикл после updateBullets и до drawEnemies.

Шаг 7: Движение врагов и условие проигрыша

Задача: Заставить врагов двигаться горизонтально как единое целое и опускаться вниз, когда они достигают края. Реализовать условие проигрыша, если враги дойдут до игрока.

Детальные инструкции для агента:

Добавь глобальные переменные для управления движением врагов: enemyDirection = 1 (1 - вправо, -1 - влево) и enemySpeed = 1.

Создай функцию updateEnemies().

Внутри функции, если массив врагов пуст (все убиты), вызови createEnemies() для начала нового раунда.

Обнови X-координату каждого живого врага: enemy.x += enemySpeed * enemyDirection.

Проверь, достиг ли любой из живых врагов левого или правого края холста. Если да, измени enemyDirection на противоположный (enemyDirection *= -1) и опусти всех врагов вниз на один шаг (увеличь enemy.y на фиксированное значение, например, на 10).

Добавь проверку на проигрыш: если Y-координата любого живого врага достигла уровня игрока (enemy.y + enemy.height >= player.y), останови игровой цикл и выведи на холст сообщение "GAME OVER".

Добавь вызов updateEnemies() в игровой цикл.

Шаг 8: Подсчет очков и финальные штрихи

Задача: Добавить систему очков и улучшить визуальную составляющую.

Детальные инструкции для агента:

Создай переменную score = 0.

В функции checkCollisions, при попадании снаряда во врага, увеличивай score (например, на 10 очков).

Создай функцию drawScore(), которая будет использовать ctx.fillText для отображения текущего счета в верхнем углу холста.

Добавь вызов drawScore() в игровой цикл.

(Опционально) Измени форму игрока и врагов с простых прямоугольников на более сложные, используя комбинацию примитивов fillRect или arc.

Убедись, что игра перезапускается после проигрыша. Для этого можно добавить обработчик события нажатия на пробел после "GAME OVER", который сбрасывает состояние игры (очищает массивы, сбрасывает счет, вызывает createEnemies()) и снова запускает gameLoop().